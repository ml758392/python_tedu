
			
shell脚本执行，如执行chdir.sh
# cat chdir.sh
#！/bin/bash
cd /tmp

1.明确声明脚本使用bash来解释的，这样脚本第一行的解释其将产生任何作用
[root@lenovo~ ]# bash chdir.sh

2.根据脚本第一行的解释器决定脚本该怎么执行，如果没有指定，默认使用bash解释
[root@lenovo~ ]#  ./chdir.sh

以上两种是
frok子进程

3.上述两种执行方法，都是fork子进程执行的，source不产生子进程
source chdir.sh 或  . chdir.sh

		[root@lenovo ~]# vim name.sh
		[root@lenovo ~]# bash name.sh
		[root@lenovo ~]# echo $name

		[root@lenovo ~]# chmod +x  name.sh
		[root@lenovo ~]# ./name.sh 
		[root@lenovo ~]# echo $name

		[root@lenovo ~]# source name.sh
		[root@lenovo ~]# echo $name
		zhangsan



			》》》进程的生命周期《《《

	僵尸进程没有任何可执行的代码，也不可能被调度	
	僵尸进程：
		1.消耗内存
		2.消耗PID号（有限的PID）

	可以试图杀死它的父进程


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

				》》》fork编程《《《

fork ()
派生子进程。
将0返回给子进程，将PID返回给父进程

	import os
	print("hello world")

	os.fork()
	print('你好'

	[root@lenovo pycharm]# python3 /root/桌面/5_张志刚/devops/Day1/pycharm/fork_1.py
	hello world
	你好
	你好



pythom中，绝大多数的函数值返回一次，os.fork将返回两次	
父进程返回子进程的PID，对于子进程，返回PID 0


	[root@lenovo pycharm]# python3 /root/桌面/5_张志刚/devops/Day1/pycharm/fork_1.py
	hello world
	12590					
	你好
	[root@lenovo pycharm]# 0
	你好


	import os
	print("hello world")

	pid = os.fork()			## 生成子进程，以下代码分别在父子进程中执行
	if pid:
	    print('父进程.......')		##os.fork()
	else:
	    print('子进程.......')
	print('你好')


	[root@lenovo pycharm]# python3 /root/桌面/5_张志刚/devops/Day1/pycharm/fork_2.py 
	hello world
	父进程.......
	你好
	子进程.......
	你好



	help(os.waitpid)
	posix模块内置函数waitpid的帮助:
	waitpid (pid,选项,/)
	等待给定子进程的完成。
	返回关于子进程的一组信息:
	(pid、状态)
	选项参数在Windows上被忽略。



waitpid()的返回值：如果子进程尚未结束则返回0，
否则返回子进程的PID 

		## 僵尸进程：
			子进程执行完代码之后，父进程没有执行完毕，此时这个子进程被称为僵尸进程

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

			
						》》》多线程《《《


线程的定义：
	再一个进程内部，要同时干多件事，就需要同时运行多个子任务，我门把进程内的这些子任务叫做线程
	线程通常叫做轻型的进程，线程是共享内存空间的并发执行的多任务，每一个线程都共享一个进程的资源


线程是最小的执行单元，而进程至少有一个线程组成
如何调度进程和线程，完全有操作系统决定，程序自己不能决定什么时候执行，执行多长时间

模块
1.thread模块 	低级模块
2.threading模块 	高级模块，对_thread进行


多线程和多进程区别
	1.多进程中，同一个变量，各自有一份拷贝存在每个进程中，互不影响
	2.多线程中，所有变量都由所有线程共享，任何一个变量都可以被任何一个线程修改
	  因此，线程只见共享数据的最大危险在于多个线程同时修改一个变量，容易把内容该乱了



			》》》线程锁《《《

	# 加锁
        # 确保了这段代码只能有一个线程从头到尾的完整执行
        # 阻止多先线程的并发执行，包含锁的某段代码世纪上只能以单线程模式执行，所以效率大大的降低了 
	# 由于可以存在多个锁，不同线程持有不同的锁，并试图或取其他的锁，可能造成死锁，导致多个线程挂起。
	只能操作系统强制终止

	import threading
	lock = threading.Lock()
		
	lock.acquire
	......
	......
	lock.release


	with lock:
		.......
		.......
	




GIL：全局解释器锁。某一时刻，值年呢个有一个线程交给python解释器，解释器把代码交给CPU


程序分类：
	计算密集型（CPU密集）应用：采用多进程可提升效率，多线程不能提升
	IO密集型应用：采用多进程，多线程可提升效率


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

				》》》threading.local《《
			
											
		# 每个线程有独立的存储空间
		# 每个线程对ThreadLocal对象都可以读写，但是互不影响
		local = threading.local
		# 作用： 为每一个线程绑定一个数据库连接，HTTP请求，用户身份信息等；
		# 这样一个线程的所有处理函数都可以非常方便的访问这些资源
	










	





^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
					》》》multiprocess《《《


启动两个进程 对此虚拟机来说有两个核心
	
	子进程0启动----37558			##子进程0，1同时启动
	子进程1启动----37559
	子进程0结束---37558,sleep1.001452s
	子进程1结束---37559,sleep1.001453s
	父进程结束


启动三个进程 
	父进程启动
	子进程0启动----37654	
	子进程1启动----37655
	子进程1结束---37655,sleep1.001444s	
	子进程2启动----37655			# 因为只有两个核心，在进程0结束之后，进程2才开始
	子进程0结束---37654,sleep3.003458s
	子进程2结束---37655,sleep3.002951s
	父进程结束








^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



















